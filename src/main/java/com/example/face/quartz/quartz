java定时任务框架（任务日程管理系统）
    Quartz 是一个功能丰富、开源的任务调度库，它可以被集成到所有的Java程序，无论是很小的单节点还是规模庞大的商业系统。Quartz可以被用来创建简单或者复杂的调度策略，以执行成千上万的任务。任务一般是指一个标准的Java组件，实际上可以是你写代码指定的任何逻辑。

    Quartz主要包含三个组件：job trigger schedule
        1 job作为作业接口，需要开发者自己实现，然后会被包装成JobDetail
        2 trigger是触发器 Quartz默认挺供了 SimpleTriggerImpl，CalendarIntervalTriggerImpl，CronTriggerImpl，DailyTimeIntervalTriggerImpl 四实实现
        3 schedule调度器 Quartz默认提供了 StdScheduler 和 RemoteScheduler 两种实现。

    quartz的启动过程
        1 创建ScheduleFactory
        2 创建Schedule
        3 创建JobDetail
        4 创建Trigger
        5 注册到Schedule ：scheduler.scheduleJob(jobDetail, trigger)
        6 启动Schedule schedule.start();

    例子：见代码

    asura源吗
        //
        // Source code recreated from a .class file by IntelliJ IDEA
        // (powered by Fernflower decompiler)
        //

        package com.asura.framework.quartz.job;

        import com.asura.framework.base.util.Check;
        import com.asura.framework.base.util.DateUtil;
        import com.asura.framework.base.util.DateUtil.IntervalUnit;
        import com.asura.framework.commons.json.Json;
        import com.asura.framework.conf.subscribe.ConfigSubscriber;
        import com.asura.framework.quartz.job.annotation.AsuraSchedule;
        import java.util.Map;
        import javax.annotation.PostConstruct;
        import org.quartz.CronScheduleBuilder;
        import org.quartz.CronTrigger;
        import org.quartz.Job;
        import org.quartz.JobBuilder;
        import org.quartz.JobDataMap;
        import org.quartz.JobDetail;
        import org.quartz.JobExecutionContext;
        import org.quartz.JobExecutionException;
        import org.quartz.JobKey;
        import org.quartz.SchedulerException;
        import org.quartz.StatefulJob;
        import org.quartz.Trigger;
        import org.quartz.TriggerBuilder;
        import org.quartz.TriggerKey;
        import org.slf4j.Logger;
        import org.slf4j.LoggerFactory;

        public abstract class AsuraJob implements StatefulJob {
            private static final Logger logger = LoggerFactory.getLogger(AsuraJob.class);

            public AsuraJob() {
            }

            public void execute(JobExecutionContext context) throws JobExecutionException {
                if (this.quartzKP()) {
                    logger.info(context.getJobDetail().getJobClass().getName() + " 定时任务空跑.....");
                } else {
                    logger.info("JOB: " + context.getJobDetail().getJobClass().getName() + " start .....");
                    long start = System.currentTimeMillis();
                    this.run(context);
                    long end = System.currentTimeMillis();
                    logger.info("JOB: " + context.getJobDetail().getJobClass().getName() + " end ..... 耗时：" + (end - start) + " 毫秒");
                }

            }

            public abstract void run(JobExecutionContext var1);

            //是否空跑定时任务 @return true 空跑 ； false 不空跑
            private boolean quartzKP() {
                String type = EnumSysConfig.asura_quartzKP.getType();
                String code = EnumSysConfig.asura_quartzKP.getCode();
                String value = ConfigSubscriber.getInstance().getConfigValue(type, code);
                if (value == null) {
                    value = EnumSysConfig.asura_quartzKP.getDefaultValue();
                }

                return "on".equals(value);
            }

            @PostConstruct
            public void addJob() {
                Class<? extends Job> clazz = this.getClass();
                // 获取Job注解对象
                AsuraSchedule annotation = (AsuraSchedule)clazz.getAnnotation(AsuraSchedule.class);
                String triggerName = clazz.getName();
                String triggerGroup = null;
                String cronExpression = null;
                String param = null;
                if (!Check.NuNObj(annotation)) {
                    triggerGroup = annotation.triggerGroup();
                    cronExpression = annotation.cronTrigger();
                    param = annotation.param();
                }

                Class<? extends Job> jobClass = clazz;
                Trigger trigger = null;

                try {
                    // triggerGroup必须和scheduleName相等，老的base依赖解决方案
                    String scheduleName = SchedulerExecutor.getScheduler().getSchedulerName();
                    if (!Check.NuNStrStrict(triggerGroup) && !triggerGroup.equals(scheduleName)) {
                        logger.info("Job is not belong this cluster, triggerGroup : {}, scheduleName : {}", triggerGroup, scheduleName);
                        return;
                    }

                    TriggerKey triggerKey = new TriggerKey(triggerName, triggerGroup);
                    JobKey jobKey = new JobKey(triggerName, "DEFAULT");
                    if (Check.NuNStr(triggerGroup) || Check.NuNStr(cronExpression)) {
                        logger.info("triggerGroup or cronExpression can not null");
                        return;
                    }

                    trigger = SchedulerExecutor.getScheduler().getTrigger(triggerKey);
                    // 判断是否有重复的触发器
                    if (trigger == null) {
                        JobDataMap jobDataMap = new JobDataMap();
                        if (!Check.NuNStr(param)) {
                            jobDataMap.put("param", Json.parseObject(param, Map.class));
                        }

                        JobDetail jobDetail = JobBuilder.newJob(jobClass).withIdentity(jobKey).storeDurably(true).setJobData(jobDataMap).build();
                        CronTrigger cronTrigger = (CronTrigger)TriggerBuilder.newTrigger().forJob(jobDetail).withIdentity(triggerKey).usingJobData(jobDataMap).startAt(DateUtil.intervalDate(10, IntervalUnit.MINUTE)).withSchedule(CronScheduleBuilder.cronSchedule(cronExpression)).build();
                        SchedulerExecutor.getScheduler().addJob(jobDetail, true);
                        SchedulerExecutor.getScheduler().scheduleJob(cronTrigger);
                        SchedulerExecutor.getScheduler().rescheduleJob(triggerKey, cronTrigger);
                        logger.info("Job add success, triggerName :" + triggerName + "triggerGroup :" + triggerGroup);
                    } else {
                        logger.info("Job already exists");
                    }
                } catch (SchedulerException var15) {
                    logger.error("", var15);
                }

            }
        }

    JobDetail和Job
        默认每次执行行job都是新创建的实例
            我们传给schedule一个JobDetail实例，因为我们在创建JobDetail时，将要执行的job的类名传给了jobDetail，所以schedule就知道了要执行何种类型的job；每当schedule执行job时，在调用其execute（）方法之前会创建一个该类的一个新的实例；执行完毕，对该实例的引用就被丢弃了，实例会被垃圾回收；这种执行策略带来的一个后果是，job必须有一个无参的构造函数（当使用默认的JobFactory时）；另一个后果是，在job类中，不应该定义由状态的数据属性，因为在job的多次执行中，这些属性的值不会保留。
        PropertySettingJobFactory 为 Job 实现属性的自动注入
        	当一个trigger被触发时，与之关联的JobDetail实例会ø被加载，JobDetail引用的job类通过配置在Schedule上的JobFactory进行初始化。默认的PropertySettingJobFactory，仅仅是调用job类的newInstance（）方法，然后尝试调用JobDataMap中的key的setter方法。你也可以创建自己的JobFactory实现，比如让你的IOC和DI容器可以创建/初始化job实例

    Job状态与并发
        @DisallowConcurrentExecution：告诉quartz不要并发地执行同一个job（这里指特定的job类）的多个实例
        @PersistJobDataAfterExecution：告诉quartz在成功执行了job类的execute方法后（没有发生任何异常），更新JobDetail中的JobDataMap的数据如果你使用了
        @PersistJobDataAfterExecution注解，强烈建议同时使用@DisallowConcurrentExecution注解，因为当同一个job（JobDetail）的两个实例并发执行时，由于竞争，JobDataMap中存储的数据很可能是不确定的
        StatefulJob就是加这两个注解的job

    Durability 和 RequestsRecovery
    	Durability：如果一个job是非持久的，当没有活跃的trigger与之关联的时候，会被自动地从schedule中删除。也就是说，非持久的job的生命期是由trigger的存在与否决定的；
    	RequestRecovery：如果一个job是可恢复的，并且在执行的时候，schedule强制关闭（比如运行的进程崩溃了，或者关机了），则当schedule重新启动的时候该 job会被重新执行。此时，该job的 JobExecutionContext.isRecovering() 返回 true

    自定义JobFactory创建job对象
        见代码

    Trigger触发器
        Trigger的六个属性
            1 jobKey关联的job，一个trigger只能关联一个JobDetail（一个job可以有多个trigger？）
            2 startTime开始触发的时间，一般为第一次触发的时间
            3 endTime结束触发的时间，一般为最后一次触发的时间
            4 priority 优先级，存在多个触发器时，优先触发的优先级
            5 misfire 失火策略，失火-job到了该执行时间且过了一定的时间后任未执行
            6 calendar 日历 需要排除的执行日期

        SimpleTrigger
            SimpleTrigger可以满足的调度需求是：在具体的时间点执行一次，或者在具体的时间点执行。并且以指定的时间间隔重复执行若干次。
            属性包括：
                startTime 开始时间
                endTime 结束时间
                repeatCount 重复次数
                repeatinterval 重复的间隔
        CronTrigger
            cron表达式
        CalendarIntervalTrigger
            SimpleTrigger的基础上添加Calendar排除指定的时间

    Schedule调度器
        开始结束调度线程
        增删改查job，trigger，calendar

    quartz的原理
    	1 job表示一个工作，要执行的具体内容。此接口中只有一个方法execute
    	2 JobDetail jobDetail表示一个具体的可执行的调度程序，Job是这个可执行调度程序所要执行的内容，另外JobDetail还包含了这个任务调度的方案和策略
    	3 Trigger代表一个调度参数的配置，什么时候去调
    	4 Schedule代表一个调度容器，一个调度容器中可以注册多个JobDetail和Trigger。当Trigger与JobDetail组合，就可以被Schedule容器调度了。

    Listeners监听器
    	提供三种监听器：TriggerListener,JobListener,ScheduleListener
    	TriggerListener
            public interface TriggerListener {

                String getName();
                //触发器触发时
                void triggerFired(Trigger var1, JobExecutionContext var2);
                //触发器被都否决，为true时不执行
                boolean vetoJobExecution(Trigger var1, JobExecutionContext var2);
                //触发失火，该触发的时候没有触发
                void triggerMisfired(Trigger var1);
                //触发完成
                void triggerComplete(Trigger var1, JobExecutionContext var2, CompletedExecutionInstruction var3);
            }
        JobListener
            public interface JobListener {
                String getName();
                //即将执行
                void jobToBeExecuted(JobExecutionContext var1);
                //被否决，不执行
                void jobExecutionVetoed(JobExecutionContext var1);
                //执行完毕
                void jobWasExecuted(JobExecutionContext var1, JobExecutionException var2);
            }
        ScheduleListener
            public interface SchedulerListener {
                //添加一个job（到可执行状态）
                void jobScheduled(Trigger var1);
                //移除一个job的执行
                void jobUnscheduled(TriggerKey var1);
                //触发完成
                void triggerFinalized(Trigger var1);
                //触发器暂停
                void triggerPaused(TriggerKey var1);

                void triggersPaused(String var1);
                //触发器恢复
                void triggerResumed(TriggerKey var1);

                void triggersResumed(String var1);

                void jobAdded(JobDetail var1);

                void jobDeleted(JobKey var1);

                void jobPaused(JobKey var1);

                void jobsPaused(String var1);

                void jobResumed(JobKey var1);

                void jobsResumed(String var1);

                void schedulerError(String var1, SchedulerException var2);

                void schedulerInStandbyMode();
                //调度线程开始
                void schedulerStarted();

                void schedulerStarting();

                void schedulerShutdown();

                void schedulerShuttingdown();

                void schedulingDataCleared();
            }

    quartz misfire策略
    	什么时候会misfire？
    		在quartz应用中，misfire job 是经常遇到的情况。一般来说，下面这些原因可能造成 misfire job。
    		1 系统因为某些原因被重启。在系统关闭到重启之间的一段时间里，可能有些任务会被misfire；
    		2 Trigger 被暂停（suspend）的一段时间里，有些任务可能会被misfire；
    		3 线程池中所有线程都被占用，导致任务无法被触发执行，造成misfire；
    		4 有状态任务在下次触发时间到达时，上次执行还没有结束。

    	misfire策略有：
    		MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY
    			忽略misfire策略，他会在资源合适的时候，重新触发所有的misfire任务，并且不会影响现有的调度时间。
    			比如，SimpleTrigger每15秒执行一次，而中间有5分钟的时间都misfire了，一共错失了20个，5分钟后，假设资源充足了，并且任务允许并发，他会被一次性触发。这个属性时所有Trigger都适用。
    		MISFIRE_INSTRUCTION_FIRE_NOW
    			忽略已经misfire的任务，并且立即执行调度。这通常只适用于只执行一次的任务。
    		MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_EXISTING_REPEAT_COUNT
    			将startTime设置当前时间，立即重新调度任务，包括misfire的
    		MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_REMAINING_REPEAT_COUNT
    			同上，不包括misfire
    		MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_EXISTING_COUNT
    			在下一次调度时间点，重新开始调度任务，包括misfire的
    		MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_REMAINING_COUNT
    			同上，忽略已经misfire的
    		MISFIRE_INSTRUCTION_SMART_POLICY
    			所有的Trigger的misfire默认值都是这个，策略交给quartz决定
    			如果是只执行一次的调度，使用MISFIRE_INSTRUCTION_FIRE_NOW
    			如果是无限次的调度，使用MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_REMAINING_COUNT
    			否则，使用MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_REMAINING_REPEAT_COUNT

    quartz线程模型
    	1 原理
    		org.quartz.SchedulerFactory#getScheduler()
    		    sched = this.instantiate();//1136
    		org.quartz.impl.StdSchedulerFactory.instantiate()
    		    //创建了一个QuartzScheduler
    		    qs = new QuartzScheduler(rsrcs, idleWaitTime, dbFailureRetry);//923
    		org.quartz.core.QuartzScheduler.QuartzScheduler
    		    //创建QuartzSchedulerThread并启动（一直执行的线程）--  调度线程
    		    this.schedThread = new QuartzSchedulerThread(this, resources);//97
    		QuartzSchedulerThread
                public void run() {
                        int acquiresFailed = 0;

                        label228:
                        while(!this.halted.get()) {
                            try {
                                //检查我们是否应该暂停
                                synchronized(this.sigLock) {
                                    for(; this.paused && !this.halted.get(); acquiresFailed = 0) {
                                        try {
                                            //等待直到togglePause（false）执行
                                            this.sigLock.wait(1000L);
                                        } catch (InterruptedException var24) {
                                        }
                                    }

                                    if (this.halted.get()) {
                                        break;
                                    }
                                }

                                if (acquiresFailed > 1) {
                                    try {
                                        long delay = computeDelayForRepeatedErrors(this.qsRsrcs.getJobStore(), acquiresFailed);
                                        Thread.sleep(delay);
                                    } catch (Exception var23) {
                                    }
                                }
                                //获取可用的线程量
                                int availThreadCount = this.qsRsrcs.getThreadPool().blockForAvailableThreads();
                                //将永远是true，由于blockForAvailableThreads的语义...
                                if (availThreadCount > 0) {
                                    long now = System.currentTimeMillis();
                                    this.clearSignaledSchedulingChange();

                                    List triggers;//定义触发器集合
                                    try {
                                        //获取30s（默认）内有没有需要执行的job，从jobStore中获取下次要触发的触发器集合。当调度程序发现没有当前触发器要触发，它应该等待多长时间再检查...
                                        /*
                                        acquireNextTriggers方法该方法关键的一点在于执行了executeInNonManagedTXLock()方法,这一方法指定了一个锁名,两个回调函数.
                                        在开始执行时获得锁,在方法执行完毕后随着事务的提交锁被释放.在该方法的底层,使用 for update语句,在数据库中加入行级锁,保证了在该方法执行过程中,
                                        其他的调度器对trigger进行获取时将会等待该调度器释放该锁.此方法是前面介绍的quartz集群策略的的具体实现,这一模板方法在后面的trigger触发过程还会被使用
                                        */
                                        triggers = this.qsRsrcs.getJobStore().acquireNextTriggers(now + this.idleWaitTime, Math.min(availThreadCount, this.qsRsrcs.getMaxBatchSize()), this.qsRsrcs.getBatchTimeWindow());
                                        acquiresFailed = 0;
                                        if (this.log.isDebugEnabled()) {
                                            this.log.debug("batch acquisition of " + (triggers == null ? 0 : triggers.size()) + " triggers");
                                        }
                                    } catch (JobPersistenceException var26) {
                                        if (acquiresFailed == 0) {
                                            this.qs.notifySchedulerListenersError("An error occurred while scanning for the next triggers to fire.", var26);
                                        }

                                        if (acquiresFailed < 2147483647) {
                                            ++acquiresFailed;
                                        }
                                        continue;
                                    } catch (RuntimeException var27) {
                                        if (acquiresFailed == 0) {
                                            this.getLog().error("quartzSchedulerThreadLoop: RuntimeException " + var27.getMessage(), var27);
                                        }

                                        if (acquiresFailed < 2147483647) {
                                            ++acquiresFailed;
                                        }
                                        continue;
                                    }

                                    //判断返回的触发器存在
                                    if (triggers != null && !triggers.isEmpty()) {
                                        now = System.currentTimeMillis();
                                        //获取最早需要触发的
                                        long triggerTime = ((OperableTrigger)triggers.get(0)).getNextFireTime().getTime();

                                        //若有没有触发的Trigger，下次触发时间 next_fire_time 这个会在启动的时候有个默认的misfire机制
                                        for(long timeUntilTrigger = triggerTime - now; timeUntilTrigger > 2L; timeUntilTrigger = triggerTime - now) {
                                            synchronized(this.sigLock) {
                                                if (this.halted.get()) {
                                                    break;
                                                }

                                                if (!this.isCandidateNewTimeEarlierWithinReason(triggerTime, false)) {
                                                    try {
                                                        now = System.currentTimeMillis();
                                                        timeUntilTrigger = triggerTime - now;
                                                        if (timeUntilTrigger >= 1L) {
                                                            this.sigLock.wait(timeUntilTrigger);
                                                        }
                                                    } catch (InterruptedException var22) {
                                                    }
                                                }
                                            }

                                            if (this.releaseIfScheduleChangedSignificantly(triggers, triggerTime)) {
                                                break;
                                            }

                                            now = System.currentTimeMillis();
                                        }

                                        if (!triggers.isEmpty()) {
                                            //将触发器设置正在执行
                                            List<TriggerFiredResult> bndles = new ArrayList();
                                            boolean goAhead = true;
                                            synchronized(this.sigLock) {
                                                goAhead = !this.halted.get();
                                            }

                                            if (goAhead) {
                                                try {
                                                    //根据Trigger获取JobDetail，并封装成TriggerFiredResult
                                                    //通知JobStore调度程序现在正在触发其先前已获取（保留）的给定触发器（执行其关联的作业）。
                                                    List<TriggerFiredResult> res = this.qsRsrcs.getJobStore().triggersFired(triggers);
                                                    if (res != null) {
                                                        bndles = res;
                                                    }
                                                } catch (SchedulerException var25) {
                                                    this.qs.notifySchedulerListenersError("An error occurred while firing triggers '" + triggers + "'", var25);
                                                    int i = 0;

                                                    while(true) {
                                                        if (i >= triggers.size()) {
                                                            continue label228;
                                                        }

                                                        this.qsRsrcs.getJobStore().releaseAcquiredTrigger((OperableTrigger)triggers.get(i));
                                                        ++i;
                                                    }
                                                }
                                            }

                                            //循环List<TriggerFiredResult> bndles 集合，获取TriggerFiredResult和TriggerFiredBundle等
                                            for(int i = 0; i < ((List)bndles).size(); ++i) {
                                                TriggerFiredResult result = (TriggerFiredResult)((List)bndles).get(i);
                                                TriggerFiredBundle bndle = result.getTriggerFiredBundle();
                                                Exception exception = result.getException();
                                                if (exception instanceof RuntimeException) {
                                                    this.getLog().error("RuntimeException while firing trigger " + triggers.get(i), exception);
                                                    this.qsRsrcs.getJobStore().releaseAcquiredTrigger((OperableTrigger)triggers.get(i));
                                                } else if (bndle == null) {
                                                    //如果触发器被暂停，阻塞或其他类似的事件阻止它在这时被触发，或者如果调度器被关闭（暂停），则可以获得'null'
                                                    this.qsRsrcs.getJobStore().releaseAcquiredTrigger((OperableTrigger)triggers.get(i));
                                                } else {
                                                    //构造执行对象，JobRunShell实现了Runnable
                                                    JobRunShell shell = null;

                                                    try {
                                                        shell = this.qsRsrcs.getJobRunShellFactory().createJobRunShell(bndle);
                                                        //用自己的job定义一个对象，并把执行job所需要的数据传给JobExecutionContextImpl
                                                        shell.initialize(this.qs);
                                                    } catch (SchedulerException var28) {
                                                        this.qsRsrcs.getJobStore().triggeredJobComplete((OperableTrigger)triggers.get(i), bndle.getJobDetail(), CompletedExecutionInstruction.SET_ALL_JOB_TRIGGERS_ERROR);
                                                        continue;
                                                    }

                                                    //使用线程池执行JobRunShell
                                                    if (!this.qsRsrcs.getThreadPool().runInThread(shell)) {
                                                        this.getLog().error("ThreadPool.runInThread() return false!");
                                                        this.qsRsrcs.getJobStore().triggeredJobComplete((OperableTrigger)triggers.get(i), bndle.getJobDetail(), CompletedExecutionInstruction.SET_ALL_JOB_TRIGGERS_ERROR);
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        //默认随机休眠 30-random.next(7) 秒
                                        long now = System.currentTimeMillis();
                                        long waitTime = now + this.getRandomizedIdleWaitTime();
                                        long timeUntilContinue = waitTime - now;
                                        synchronized(this.sigLock) {
                                            try {
                                                if (!this.halted.get() && !this.isScheduleChanged()) {
                                                    this.sigLock.wait(timeUntilContinue);
                                                }
                                            } catch (InterruptedException var19) {
                                            }
                                        }
                                    }
                                }
                            } catch (RuntimeException var31) {
                                this.getLog().error("Runtime error occurred in main trigger firing loop.", var31);
                            }
                        }

                        //删除对调度程序内容的引用以帮助垃圾回收...
                        this.qs = null;
                        this.qsRsrcs = null;
                    }
                    triggersFired
                    public List<TriggerFiredResult> triggersFired(final List<OperableTrigger> triggers) throws JobPersistenceException {
                            return executeInNonManagedTXLock(LOCK_TRIGGER_ACCESS,
                                    new TransactionCallback<List<TriggerFiredResult>>() {
                                        public List<TriggerFiredResult> execute(Connection conn) throws JobPersistenceException {
                                            List<TriggerFiredResult> results = new ArrayList<TriggerFiredResult>();
                                            TriggerFiredResult result;
                                            for (OperableTrigger trigger : triggers) {
                                                try {
                                                  TriggerFiredBundle bundle = triggerFired(conn, trigger);
                                                  result = new TriggerFiredResult(bundle);
                                                } catch (JobPersistenceException jpe) {
                                                    result = new TriggerFiredResult(jpe);
                                                } catch(RuntimeException re) {
                                                    result = new TriggerFiredResult(re);
                                                }
                                                results.add(result);
                                            }
                                            return results;
                                        }
                                    },
                                    new TransactionValidator<List<TriggerFiredResult>>() {
                                        @Override
                                        public Boolean validate(Connection conn, List<TriggerFiredResult> result) throws JobPersistenceException {
                                            //...异常处理回调方法
                                        }
                                    });
                        }
                    executeInNonManagedTXLock
                    protected <T> T executeInNonManagedTXLock(String lockName, JobStoreSupport.TransactionCallback<T> txCallback, final JobStoreSupport.TransactionValidator<T> txValidator) throws JobPersistenceException {
                            boolean transOwner = false;
                            Connection conn = null;

                            Object var8;
                            try {
                                if (lockName != null) {
                                    if (this.getLockHandler().requiresConnection()) {
                                        conn = this.getNonManagedTXConnection();
                                    }

                                    //获取锁
                                    transOwner = this.getLockHandler().obtainLock(conn, lockName);
                                }

                                if (conn == null) {
                                    conn = this.getNonManagedTXConnection();
                                }

                                final Object result = txCallback.execute(conn);

                                try {
                                    this.commitConnection(conn);
                                } catch (JobPersistenceException var31) {
                                    this.rollbackConnection(conn);
                                    if (txValidator == null || !(Boolean)this.retryExecuteInNonManagedTXLock(lockName, new JobStoreSupport.TransactionCallback<Boolean>() {
                                        public Boolean execute(Connection conn) throws JobPersistenceException {
                                            return txValidator.validate(conn, result);
                                        }
                                    })) {
                                        throw var31;
                                    }
                                }

                                Long sigTime = this.clearAndGetSignalSchedulingChangeOnTxCompletion();
                                if (sigTime != null && sigTime >= 0L) {
                                    this.signalSchedulingChangeImmediately(sigTime);
                                }

                                var8 = result;
                            } catch (JobPersistenceException var32) {
                                this.rollbackConnection(conn);
                                throw var32;
                            } catch (RuntimeException var33) {
                                this.rollbackConnection(conn);
                                throw new JobPersistenceException("Unexpected runtime exception: " + var33.getMessage(), var33);
                            } finally {
                                try {
                                    //释放锁
                                    this.releaseLock(lockName, transOwner);
                                } finally {
                                    this.cleanupConnection(conn);
                                }
                            }

                            return var8;
                        }


                    triggerFired
                    protected TriggerFiredBundle triggerFired(Connection conn,
                                OperableTrigger trigger)
                            throws JobPersistenceException {
                            JobDetail job;
                            Calendar cal = null;
                            // Make sure trigger wasn't deleted, paused, or completed...
                            try { // if trigger was deleted, state will be STATE_DELETED
                                //获取trigger的当前状态
                                String state = getDelegate().selectTriggerState(conn,
                                        trigger.getKey());
                                if (!state.equals(STATE_ACQUIRED)) {
                                    return null;
                                }
                            } catch (SQLException e) {
                                throw new JobPersistenceException("Couldn't select trigger state: "
                                        + e.getMessage(), e);
                            }
                            try {
                                //通过trigger的jobKey获取jobDetail
                                job = retrieveJob(conn, trigger.getJobKey());
                                if (job == null) { return null; }
                            } catch (JobPersistenceException jpe) {
                                try {
                                    getLog().error("Error retrieving job, setting trigger state to ERROR.", jpe);
                                    //将trigger更新至触发状态
                                    getDelegate().updateTriggerState(conn, trigger.getKey(),
                                            STATE_ERROR);
                                } catch (SQLException sqle) {
                                    getLog().error("Unable to set trigger state to ERROR.", sqle);
                                }
                                throw jpe;
                            }

                        if (trigger.getCalendarName() != null) {
                                    //获取Calendar信息
                                    cal = retrieveCalendar(conn, trigger.getCalendarName());
                                    if (cal == null) { return null; }
                                }
                                try {
                                    //更新trigger信息至STATE_EXECUTING
                                    getDelegate().updateFiredTrigger(conn, trigger, STATE_EXECUTING, job);
                                } catch (SQLException e) {
                                    throw new JobPersistenceException("Couldn't insert fired trigger: "
                                            + e.getMessage(), e);
                                }
                                //计算下一次触发时间
                                Date prevFireTime = trigger.getPreviousFireTime();
                                // call triggered - to update the trigger's next-fire-time state...
                                trigger.triggered(cal);
                                String state = STATE_WAITING;
                                boolean force = true;
                                
                                if (job.isConcurrentExectionDisallowed()) {
                                    state = STATE_BLOCKED;
                                    force = false;
                                    try {
                                        getDelegate().updateTriggerStatesForJobFromOtherState(conn, job.getKey(),
                                                STATE_BLOCKED, STATE_WAITING);
                                        getDelegate().updateTriggerStatesForJobFromOtherState(conn, job.getKey(),
                                                STATE_BLOCKED, STATE_ACQUIRED);
                                        getDelegate().updateTriggerStatesForJobFromOtherState(conn, job.getKey(),
                                                STATE_PAUSED_BLOCKED, STATE_PAUSED);
                                    } catch (SQLException e) {
                                        throw new JobPersistenceException(
                                                "Couldn't update states of blocked triggers: "
                                                        + e.getMessage(), e);
                                    }
                                }

                        if (trigger.getNextFireTime() == null) {
                                    state = STATE_COMPLETE;
                                    force = true;
                                }
                                storeTrigger(conn, trigger, job, true, state, force, false);
                                job.getJobDataMap().clearDirtyFlag();
                                return new TriggerFiredBundle(job, trigger, cal, trigger.getKey().getGroup()
                                        .equals(Scheduler.DEFAULT_RECOVERY_GROUP), new Date(), trigger
                                        .getPreviousFireTime(), prevFireTime, trigger.getNextFireTime());
                            }

                org.quartz.core.JobRunShell.run
                    OperableTrigger trigger = (OperableTrigger)this.jec.getTrigger();
                    JobDetail jobDetail = this.jec.getJobDetail();
                    JobExecutionException jobExEx = null;
                    Job job = this.jec.getJobInstance();
                    long startTime = System.currentTimeMillis();
                    job.execute(this.jec);
                    endTime = System.currentTimeMillis();
                    this.jec.setJobRunTime(endTime - startTime);
    JobStore Quartz Job 数据存储
    	quartz中的trigger和job需要存储下来才能被使用。quartz中有两种存储方式：RAMJobStore，JobStoreSupport，
    	其中RAMJobStore是将trigger和job存储在内存中，不用外部数据库，不用配置，运行速度快，RAMJobStore的存取速度非常快，但是由于其在系统停止后所有的数据都会丢失，另外因为存储到JVM内存里面，所以可以存储多少个Job和Trigger将会受到限制
    	而JobStoreSupport是基于JDBC将trigger和job存储到数据库中。在集群应用中，必须使用JobStoreSupport，他有两个实现JobStoreTX（自己管理事务），JobStoreCMT（容器管理事务）。运行速度的快慢取决于数据库链接的快慢。


    	cron方式需要用到的4张数据表：
    		qrtz_triggers
    		qrtz_cron_triggers
    		qrtz_fired_triggers
    		qrtz_job_details

    	主要的JDBC操作类：执行sql顺序
    		SimpleTrigger
    			qrtz_job_details -> qrtz_triggers -> qrtz_simple_triggers
    			qrtz_fired_triggers
    		CronTrigger
    			qrtz_job_details -> qrtz_triggers -> qrtz_cron_triggers
    			qrtz_fired_triggers
    quartz集群原理
    	锁机制
    		CALENDAR_ACCESS
			JOB_ACCESS
			MISFIRE_ACCESS
			STATE_ACCESS
			TRIGGER_ACCESS

			qrtz_locks中五条记录，代表五把锁，分别用于实现多个Quartz Node对Job，Trigger，Calendar访问的同步控制

		SELECT * FROM {0}LOCKS WHERE SCHED_NAME = {1} AND LOCK_NAME = ? FOR UPDATE

		行锁的机制：
		1、mysql >  set autocommit=0;    //先把mysql设置为不自动提交。
		2、 select * from es_locks where lock_name = 'TRIGGER_ACCESS' for update ;     //线程一通过for update 可以把这行锁住
		3、 select * from es_locks where lock_name = 'TRIGGER_ACCESS' for update ;     //线程二通过for update 无法获得锁，线程等待。
		4、commit;        //线程一通过commit 释放锁
		5、 //线程二可以访问到数据，线程不再等待。
		通过这个机制，一次只能有一个线程来操作 加锁 -  操作 - 释放锁。  如果 操作 的时间过长的话，会带来集群间的主线程等待。
		数据库行锁是一种悲观锁，锁表时其它线程无法查询。

		TRIGGER_ACCESS锁
			主要是QuartzScheduleThread来操作
			1，先获取线程池的可用线程数量（若没有可用的会阻塞，直到有可用的）
			2，获取30秒内要执行的trigger（即acquireNextTriggers）

			获取trigger的锁，通过select...for update 方式实现，获取30秒内（可配置）要执行的triggers（需要保证集群节点的时间一致），若@ConcurrentExectionDisallowed且列表存在该条trigger则跳过，否则更新trigger状态为ACQUIRED（刚开始为WAITING），插入firedTrigger表，状态为ACQUIRED（注意：在RAMJobStore中有个timeTriggers，排序方式是按照触发时间nextFireTime排的，JobStoreSupport从数据库取出trigger时时按照nextFireTime排序）；

			等待知道获取的trigger中最先执行的trigger在2ms内；
			triggersFired

			3 等待直到获取的trigger中最先执行的trigger在2ms内
            4 triggerFired
            	更新firedTrigger的status=EXECUTING；
            	更新trigger下一次触发的时间；
            	更新trigger的状态：无状态的trigger->WAITING，有状态的trigger->BLOCKED,若nextFireTime==null->COMPLETE；
            	commit connection，释放锁
            5 针对每个要执行的trigger，创建JobRunShell，并放入线程池执行。
            	execute：执行job
            	获取TRIGGER_ACCRESS锁
            	若是有状态的job：更新trigger状态：BLOCKED-》WAITING，PAUSED_BLOCKED->BLOCKED
            	若@PersistJobDataAfterExecution，则updateJobData
            	删除firedTrigger
            	commit connection ，释放锁
        STATE_ACCESS集群锁
        	调度器状态表（qrtz_schedule_state）记录了集群中节点实例信息，Quartz定时读取该表的信息判断集群中每个实例的当前状态。
        	org.quartz.impl.jdbcjobstore.JobStoreSupport.ClusterManager

        	三个字段含义
        		instance_name：配置文件中org.quartz.scheduler.instanceId配置的名字，如果设置为AUTO，quartz会根据物理机名和当前时间产生一个名字
        		last_checkin_time：上次检入时间
        		checkin——interval：检入间隔时间

        	如果last_checkin_time + checkin_interval与现在时间相差太大的时候，quartz就认为这个节点挂了，就需要其他节点给他处理善后（比如改变qrtz_fired_triggers中记录的状态），以便以集群中其他的节点来替代它执行原本应该他来执行的定时任务。然后就需要获取STATE_ACCESS来保证同一时间只有一个节点在操作这些。这些原本由他来处理的任务，如果还没来得及执行，就有可能导致定时任务的失火。

            org.quartz.impl.jdbcjobstore.JobStoreSupport.ClusterManager
            class ClusterManager extends Thread {
                private volatile boolean shutdown = false;
                private int numFails = 0;

                ClusterManager() {
                    this.setPriority(7);
                    this.setName("QuartzScheduler_" + JobStoreSupport.this.instanceName + "-" + JobStoreSupport.this.instanceId + "_ClusterManager");
                    this.setDaemon(JobStoreSupport.this.getMakeThreadsDaemons());
                }

                public void initialize() {
                    this.manage();
                    ThreadExecutor executor = JobStoreSupport.this.getThreadExecutor();
                    executor.execute(this);
                }

                public void shutdown() {
                    this.shutdown = true;
                    this.interrupt();
                }

                private boolean manage() {
                    boolean res = false;

                    try {
                        res = JobStoreSupport.this.doCheckin();
                        this.numFails = 0;
                        JobStoreSupport.this.getLog().debug("ClusterManager: Check-in complete.");
                    } catch (Exception var3) {
                        if (this.numFails % 4 == 0) {
                            JobStoreSupport.this.getLog().error("ClusterManager: Error managing cluster: " + var3.getMessage(), var3);
                        }

                        ++this.numFails;
                    }

                    return res;
                }

                public void run() {
                    while(!this.shutdown) {
                        if (!this.shutdown) {
                            long timeToSleep = JobStoreSupport.this.getClusterCheckinInterval();
                            long transpiredTime = System.currentTimeMillis() - JobStoreSupport.this.lastCheckin;
                            timeToSleep -= transpiredTime;
                            if (timeToSleep <= 0L) {
                                timeToSleep = 100L;
                            }

                            if (this.numFails > 0) {
                                timeToSleep = Math.max(JobStoreSupport.this.getDbRetryInterval(), timeToSleep);
                            }

                            try {
                                Thread.sleep(timeToSleep);
                            } catch (Exception var6) {
                            }
                        }

                        if (!this.shutdown && this.manage()) {
                            JobStoreSupport.this.signalSchedulingChangeImmediately(0L);
                        }
                    }

                }
            }

            org.quartz.impl.jdbcjobstore.JobStoreSupport.doCheckin
                protected boolean doCheckin() throws JobPersistenceException {
                    boolean transOwner = false;
                    boolean transStateOwner = false;
                    boolean recovered = false;
                    //获取数据库链接
                    Connection conn = this.getNonManagedTXConnection();

                    try {
                        List<SchedulerStateRecord> failedRecords = null;
                        //不是第一次检入，查询是否有挂了的节点
                        if (!this.firstCheckIn) {
                            failedRecords = this.clusterCheckIn(conn);
                            this.commitConnection(conn);
                        }

                        //第一次检入，或许有挂了的节点
                        if (this.firstCheckIn || failedRecords.size() > 0) {
                            //获取集群锁 STATE_ACCESS
                            this.getLockHandler().obtainLock(conn, "STATE_ACCESS");
                            transStateOwner = true;
                            //获取锁后再次查询
                            failedRecords = this.firstCheckIn ? this.clusterCheckIn(conn) : this.findFailedInstances(conn);
                            //有挂了的实例
                            if (failedRecords.size() > 0) {
                                //获取trigger操作锁：TRIGGER_ACCESS
                                this.getLockHandler().obtainLock(conn, "TRIGGER_ACCESS");
                                transOwner = true;
                                //处理善后
                                this.clusterRecover(conn, failedRecords);
                                recovered = true;
                            }
                        }

                        //提交事务
                        this.commitConnection(conn);
                    } catch (JobPersistenceException var66) {
                        //回滚事务
                        this.rollbackConnection(conn);
                        throw var66;
                    } finally {
                        try {
                            //释放TRIGGER_ACCESS
                            this.releaseLock("TRIGGER_ACCESS", transOwner);
                        } finally {
                            try {
                                //释放STATE_ACCESS
                                this.releaseLock("STATE_ACCESS", transStateOwner);
                            } finally {
                                //清理数据库链接
                                this.cleanupConnection(conn);
                            }
                        }
                    }

                    this.firstCheckIn = false;
                    return recovered;
                }

    配置文件
         quartz.properties
            //调度标识名 集群中每一个实例都必须使用相同的名称 （区分特定的调度器实例）
            org.quartz.scheduler.instanceName：DefaultQuartzScheduler
            //ID设置为自动获取 每一个必须不同 （所有调度器实例中是唯一的）
            org.quartz.scheduler.instanceId ：AUTO
            //数据保存方式为持久化
            org.quartz.jobStore.class ：org.quartz.impl.jdbcjobstore.JobStoreTX
            //表的前缀
            org.quartz.jobStore.tablePrefix ： QRTZ_
            //设置为TRUE不会出现序列化非字符串类到 BLOB 时产生的类版本问题
            //org.quartz.jobStore.useProperties ： true
            //加入集群 true 为集群 false不是集群
            org.quartz.jobStore.isClustered ： false
            //调度实例失效的检查时间间隔
            org.quartz.jobStore.clusterCheckinInterval：20000
            //容许的最大作业延长时间
            org.quartz.jobStore.misfireThreshold ：60000
            //ThreadPool 实现的类名
            org.quartz.threadPool.class：org.quartz.simpl.SimpleThreadPool
            //线程数量
            org.quartz.threadPool.threadCount ： 10
            //线程优先级
            org.quartz.threadPool.threadPriority ： 5（threadPriority 属性的最大值是常量 java.lang.Thread.MAX_PRIORITY，等于10。最小值为常量 java.lang.Thread.MIN_PRIORITY，为1）
            //自创建父线程
            //org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread： true
            //数据库别名
            org.quartz.jobStore.dataSource ： qzDS
            //设置数据源
            org.quartz.dataSource.qzDS.driver:com.mysql.jdbc.Driver
            org.quartz.dataSource.qzDS.URL:jdbc:mysql://localhost:3306/quartz
            org.quartz.dataSource.qzDS.user:root
            org.quartz.dataSource.qzDS.password:123456
            org.quartz.dataSource.qzDS.maxConnection:10

    缺点
        quartz还有一个问题就是不支持cluster。导致使用quartz的应用都没有办法做群集。

        如果是我的话，我采取的办法就是自己单独启动一个Job Server，来跑job，不会部署在web容器中。

        其他web节点当需要启动异步任务的时候，可以通过种种方式(DB, JMS, Web Service, etc)通知Job Server，而Job Server收到这个通知之后，把异步任务加载到自己的任务队列中去。

        其实想改造当前已经集成quartz的web应用也不算困难：

        例如可以使用数据库的表来记录和维护任务队列和状态，把quartz部分完全从web应用中剥离出去，自己写一个Java Main程序把配置quartz的spring容器跑起来，这样Job Server就启动了(注意这个Job Server完全脱离tomcat)。此外这个Main程序应该再启动一个子线程，定期扫描数据库的任务队列表：
        有新的任务就加入quartz的任务调度；
        把当前任务的执行状态写入任务表；
        看到删除任务的表字段状态以后，删除相应的任务。

        然后web应用去掉quartz部分配置，把原来的调用quartz任务的代码改写为读写数据库的任务表，这样就把job部分完全从web容器剥离掉了，甚至web容器做cluster也没有问题了，并且多个web节点在同时读写任务表的时候，还有数据库的事务来确保操作的一致性，实在是很棒。

        另外还可以单独做一个job管理界面，可以通过web界面手工添加任务，查看任务状态，删除任务等等。

    三种集群方案
    	1 单独启动一个JobServer来跑job，不部署在web容器中，其他web节点当需要启动异步任务的时候，可以通过种种方式（DB，JMS，Web，Service，etc）通知Job Server，而Job Server收到这个通知之后，把异步任务加载到自己的任务队列中去。
    	2 独立出一个jobserver，这个server上跑一个Spring+quartz的应用，这个应用专门用来启动任务，在jobserver上加上hessain，得到业务接口，这样job server就可以调用web container、中的业务操作，也就是真正执行任务的还是cluster中的tomcat。在jobserver启动定时任务之后，轮流调用各地址上的业务操作（类似apache分发tomcat一样），这样可以让不同的定时任务在不同的节点上运行，减低了一台某个node的压力。
    	3 quartz本身事实上也是支持集群的。在这种方案下，cluster上的每一个node都在跑quartz，然后也是通过数据中记录的状态来判断这个操作是否正在执行，这就要求cluster上所有的node的时间应该是一样的，而且每一个node都跑应用意味着每一个node都需要有自己的线程池来跑quartz。

    	总的来说，第一种方法对任务饿适用范围有很大的限制，要访问在web环境中的各种资源非常麻烦，但是集中式的管理容易从架构上规避了分布式环境的种种同步问题，第二种方法在第一种的基础上减轻了job server的重量，只发送调用请求，不直接执行任务，这样解决了独立server无法访问web环境的问题，而且可以做到节点的轮询，可以有效的负载均衡。第三种方法是quartz自身支持的集群方案，在架构上完全是分布式的，没有集中的管理，quartz通过数据库锁以及标识字段保证多个节点对任务不重复获取，并且有负载均衡机制和容错机制，用少量的冗余，换取了高可用性（high amiable HA）和高可靠性（个人认为和git的机制很像，分布式的冗余设计，换取可靠性和速度）

    集群架构
	    数据库是各节点上调度器的枢纽，各个节点并不感知其他节点的存在，只是通过数据库来进行间接的沟通。

	    实际上，quartz分布式策略就是一种以数据库作为边界资源的并发异步策略，每个节点都遵守相同的操作规范，使得对数据库的操作可以串行执行，而不同名称的调度器又可以互不影响的并行执行。（同时多个节点的异步运行保证了服务的可靠，但这种策略有自己的局限性）

	    集群特性对于高cpu使用率的任务效果很好，但是对于大量的短任务，各个节点都会抢占数据库锁，这样就出现大量的线程等待资源，这种情况随着节点的增加会越来越严重。

	quartz问题：
    	1 调用API的方式操作任务，不人性化
    	2 需要持久化业务QuartzJobBean到底层数据表中，系统侵入性相当严重
    	3 调度逻辑和QuartzJobBean耦合在同一个项目中，这将导致一个问题，在调度任务数量逐渐增多，同时调度任务逻辑逐渐加重的情况下，此时调度系统的性能将大大受限于业务。
    	4 quartz底层以“抢占式”获取DB锁并由抢占成功节点负责运行任务，会导致节点负载悬殊非常大；而XXL-JOB通过执行器实现“协同分配式”运行任务，充分发挥集群优势，负载各节点均衡。

美团CRM系统任务调度模块历程
    1 Crontab+SQL
        每天晚上运行定时任务，通过SQL脚本+crontab方式执行
        问题：
            直接访问数据库，各系统业务接口没有重用
            完成复杂业务需求时，会引入过多中间表
            业务逻辑计算完全依赖SQL，增大数据库压力
            任务失败无法自动恢复
    2 Python+SQL
        采用python脚本（多数据源）+SQL方式执行
        问题：
            直接访问数据，需要理解各系统的数据结构，无法满足动态任务问题，各系统业务接口没有重用。
            无负载均衡。
            任务失败无法恢复。在JAVA语言开发中出现异构，且很难统一到自动部署系统中。
    3 Spring+JDK Timer
        调用接口完成定时任务，在分布式部署环境下，防止多个节点同时运行任务，需要写死host，控制在一台服务器上执行task。
        问题：
            步骤复杂，分散，任务量增大的情况下，很难扩展
            使用写死服务器host的方式执行task，存在单点分险，负载均衡手动完成
            应用重启，任务无法自动恢复

    弯路：
        定时任务多种实现方式，使配置和代码分散在多处，难以维护和监控；
        任务执行过程没有保证，没有错误恢复；
        任务执行异常没有反馈（邮件）；
        没有集群支持，负载均衡

    4 quartz
        优点：
            完全由java写成，方便集成（Spring）
            伸缩性
            负载均衡
            高可用性
